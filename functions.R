source("config.R")

make_graph <- function(participants, edges, semester_a, night_a, strength_a, survey_no_a=NA, sender_role=NA, receiver_role=NA, strength_mode="within", strength_err=0.5){
  # construct adjacency and vertices
  verts <- participants[which(with(participants, semester==semester_a & night==night_a)), ]
  #verts <- participants[with(participants, semester==semester_a), ]
  #verts <- subset(verts, !duplicated(verts$final_id))
  #verts <- unique(verts, incomparables=colnames(verts)[2:length(colnames)])
  
  adj <- edges[which(with(edges, semester==semester_a & night==night_a & sender_missing==0 & receiver_missing==0 & sn1==1 & !is.na(sn1) & !is.na(sn2))), ]
  if(!is.na(survey_no_a)){
    adj <- adj[which(with(adj, survnum==survey_no_a )), ]
  }
  # what strength edges to include?
  if(strength_mode=="atleast"){
    adj <- adj[with(adj, sn2>=strength_a), ]
  } else if(strength_mode=="atmost"){
    adj <- adj[with(adj, sn2<=strength_a), ]
  } else if(strength_mode=="exact"){
    adj <- adj[with(adj, sn2==strength_a), ]
  } else if(strength_mode=="within"){
    adj <- adj[with(adj, sn2<strength_a + strength_err & sn2 >= strength_a - strength_err), ]
  } else {
    stop(paste("Invalid strength_mode:", strength_mode))
  }
  # select only specific edges based on role?
  if(!is.na(sender_role) || !is.na(sender_role)){
    tmp_df <- subset(verts, select=c("final_id","role"))
  }
  if(!is.na(sender_role)){
    colnames(tmp_df)[1] <- "sender_final_id"
    tmp_adj <- join(adj, tmp_df)
    adj <- tmp_adj[tmp_adj$role==sender_role,]
  }
  if(!is.na(receiver_role)){
    colnames(tmp_df)[1] <- "receiver_final_id"
    tmp_adj <- join(adj, tmp_df)
    adj <- tmp_adj[tmp_adj$role==receiver_role,]
  }
  # reorder columns to work with igraph
  edge_columns <- c("sender_final_id", "receiver_final_id")
  other_columns <- colnames(adj)[!colnames(adj) %in% edge_columns]
  adj <- adj[, c(edge_columns, other_columns)]
  
  # check that all necessry vertices exist
  v_ids <- unique(verts$final_id)
  es_ids <- unique(adj$sender_final_id)
  er_ids <- unique(adj$receiver_final_id)
  if(!all(es_ids %in% v_ids)){
    print(paste("Sender IDs not in vertices:", toString(subset(es_ids, !(es_ids %in% v_ids)))))
  }
  if(!all(er_ids %in% v_ids)){
    print(paste("Receiver IDs not in vertices:", toString(subset(er_ids, !(er_ids %in% v_ids)))))
  }
  
  
  # create network
  net <- graph_from_data_frame(adj, vertices=verts)
  net <- simplify(net, remove.multiple=TRUE, remove.loops=TRUE)
  return(net)
}

role_degree_distribution <- function(net, role_a, ...){
  degs = degree(net, V(net)[V(net)$role==role_a], ...)
  tabulate(degs+1, nbins=max(degs)-min(degs)+1) # the +1 here is because tabulate starts at 1, but we want to count zero degree vertices as well
}

graph_stats <- function(net){
  degdist = degree_distribution(net, loops=FALSE, mode="total")
  mentor_degdist = role_degree_distribution(net, "mentor", loops=FALSE, mode="total")
  mentor_in_degdist = role_degree_distribution(net, "mentor", loops=FALSE, mode="in")
  mentor_out_degdist = role_degree_distribution(net, "mentor", loops=FALSE, mode="out")
  mentee_degdist = role_degree_distribution(net, "mentee", loops=FALSE, mode="total")
  mentee_in_degdist = role_degree_distribution(net, "mentee", loops=FALSE, mode="in")
  mentee_out_degdist = role_degree_distribution(net, "mentee", loops=FALSE, mode="out")
  return(list(degdist, mentor_degdist, mentor_in_degdist, mentor_out_degdist, mentee_degdist, mentee_in_degdist, mentee_out_degdist))
}

day_degree_plot <- function(degs, file_prefix, title_prefix, scale_factor, om, ma, plot_rows, plot_cols, colfunc, semesters, nights, strengths, survey_nos, max_deg){
  for(i in 1:length(semesters)){
    for(k in 1:length(strengths)){
      pdf(paste(paste(paste(output_dir, "deg_dists/", file_prefix, "_dist", sep="") ,semesters[i],"all-nights", toString(strengths[k]), "all-surv", sep="_"), ".pdf", sep=""), width=plot_cols*scale_factor, height=plot_rows*scale_factor)
      par(mfrow=c(plot_rows, plot_cols), mar=c(ma, ma, ma, ma), oma=c(om, om, om, om))
      ymax = max(degs[i, , k, , ])
      for(j in 1:length(nights)){
        matplot(1:max_deg, t(degs[i, j, k, , ]), main=nights[j], pch=".", type="l", lty=1, ylab=NA, xlab=NA, col=colfunc(length(survey_nos)), ylim=c(0, ymax))
      }
      title = paste(title_prefix, "Distribution for", semesters, "with a threshold of:", toString(strengths[k]), sep=" ")
      mtext(title, side=3, adj=0.5, line=0, outer=TRUE, cex=scale_factor/4)
      dev.off()
    }
  }
}

plot_graph <- function(net, arrow_size=0.3, vertex_size=10){
  V(net)$color <- role_pallete[V(net)$role_num]
  alph=0.5
  E(net)$color <- unname(sapply(role_pallete[tail_of(net, E(net))$role_num], function(x){x = col2rgb(x, alpha=TRUE); return(rgb(x[1]/255, x[2]/255, x[3]/255, alph))}))
 
  # plot it 
  lay = layout.circle
  plot(net, edge.arrow.size=arrow_size, vertex.size=vertex_size, vertex.label=NA, layout=lay, vertex.frame=FALSE)
}

add_mtext <- function(x_title, x_labs, y_title, y_labs, scale_factor=1.0){
  mtext(x_title, side=3, adj=0.5, line=3, outer=TRUE, cex=scale_factor/1.5)
  for(i in 1:length(x_labs)){
    mtext(x_labs[i], side=3, adj=i/length(x_labs) - 1/(2*length(x_labs)), outer=TRUE, cex=scale_factor/1.5)
  }
  mtext(y_title, side=2, adj=0.5, line=3, outer=TRUE, cex=scale_factor/1.5)
  for(i in 1:length(y_labs)){
    mtext(y_labs[length(y_labs)-i+1], side=2, adj=i/length(y_labs) - 1/(2*length(y_labs)), outer=TRUE, cex=scale_factor/1.5)
  }
}


day_ave_degree_plot <- function(degs, file_suffix, title_prefix, scale_factor, colrs, semesters, nights, strengths, survey_nos, max_deg){
  for(i in 1:length(semesters)){
    if(file_suffix != ""){
      filename=paste(paste(paste(output_dir, semesters[i], sep=""), "degree_ave", "allnights", "allsurv", file_suffix, sep="_"), ".pdf", sep="")
    } else {
      filename=paste(paste(paste(output_dir, semesters[i], sep=""), "degree_ave", "allnights", "allsurv", sep="_"), ".pdf", sep="")
    }
    pdf(filename, width=plot_cols*scale_factor, height=plot_rows*scale_factor)
    strength_plots = vector(mode="list", length=length(strengths))
    for(k in 1:length(strengths)){
      df <- data.frame(1:length(survey_nos))
      colnames(df) <- c("surv")
      for(j in 1:length(nights)){
        means <- (degs[i, j, k, , ] %*% 0:(max_deg-1))[,1]/sum(degs[i, j, k, , ])
        df[nights[j]] <- means
      }
      df <- melt(df, id.vars="surv")
      p <- ggplot(data=df, aes(x=surv, y=value, col=variable)) + geom_point() + geom_line()
      p <- p + ggtitle(toString(strengths[k])) + ylab(NULL) + xlab(NULL) + theme(legend.position="none")
      strength_plots[[k]] <- p 
    }
    strength_plots[[k+1]] <- ggplot(data=df, aes(x=surv, y=value, col=variable)) + geom_point() + geom_line()
    print(grid.arrange(grobs=strength_plots))
    dev.off()
  }
}


plot_outedges_byperson <- function(edges, semester_a, night_a, role_a, scale_factor=3, point_size=0.5, alpha_a=0.5){
  # get subset of edges
  edges_subset <- edges[with(edges, semester==semester_a & night==night_a & sender_role==role_a),]
  # order them so lines plot correctly
  #edges_subset <- edges_subset[with(edges_subset, order(sender_final_id, !dyad, receiver_final_id, survnum)),]
  edges_subset <- edges_subset[with(edges_subset, order(sender_final_id, receiver_final_id, survnum)),]
  # setup plot
  grid_size <- as.integer(sqrt(length(unique(edges_subset$sender_final_id))))+1
  filen <- paste(paste(paste(output_dir, semester_a, "_outedges_byperson", sep="") , night_a, role_a, sep="_"), ".pdf", sep="")
  pdf(filen, width=grid_size*scale_factor, height=grid_size*scale_factor)
  # plot
  #dyad_edges = subset(edges_subset, dyad==TRUE)
  #non_dyad_edges = subset(edges_subset, dyad==FALSE)
  #pd <- position_dodge(0.1)
  p <- ggplot(edges_subset, aes(x=survnum, y=sn2, color=dyad, group=receiver_final_id))
  #p <- ggplot(edges_subset)
  #p <- p + geom_point(aes(x=survnum, y=sn2), data=non_dyad_edges, alpha=alpha_a, size=point_size, position=pd)
  #p <- p + geom_line(aes(x=survnum, y=sn2, group=pair_id), data=non_dyad_edges, alpha=alpha_a, position=pd)
  #p <- p + geom_point(aes(x=survnum, y=sn2), data=dyad_edges, alpha=alpha_a, size=point_size, position=pd)
  #p <- p + geom_line(data=dyad_edges, aes(x=survnum, y=sn2, group=pair_id), alpha=alpha_a, position=pd)
  p <- p + geom_point(alpha=alpha_a, size=point_size)
  p <- p + geom_line(alpha=alpha_a)
  p <- p + theme(legend.position="none", panel.grid.major.y=element_line(linetype=2, color="grey50")) + dyad_color + xlab("Suvey Number") + ylab("Relationship Strength")
  p <- p + scale_y_continuous(breaks=seq(0,10,2)) + scale_x_continuous(breaks=seq(0,5,1))
  p <- p + facet_wrap(~sender_final_id)
  p <- p + scale_alpha(guide="none")    
  print(p)
  # close the pdf
  dev.off()
}

plot_outedges_dyadonly <- function(edges, semester_a, night_a, role_a, scale_factor=3, point_size=1, alpha_a=0.5){
  # get subset of edges
  edges_subset <- edges[with(edges, semester==semester_a & night==night_a & sender_role==role_a & dyad==TRUE),]
  # order them so lines plot correctly
  edges_subset <- edges_subset[with(edges_subset, order(semester, night, sender_final_id, receiver_final_id, survnum)),]
  # setup plot
  grid_size <- as.integer(sqrt(length(unique(edges_subset$sender_final_id))))+1
  filen <- paste(paste(paste(output_dir, semester_a, "_outedges_dyadonly", sep="") , night_a, role_a, sep="_"), ".pdf", sep="")
  pdf(filen, width=grid_size*scale_factor, height=grid_size*scale_factor)
  # plot
  p <- ggplot(edges_subset, aes(x=survnum, y=sn2, color=dyad))
  p <- p + geom_point(alpha=alpha_a) + geom_line(aes(group=edges_subset$pair_id), alpha=alpha_a)
  p <- p + theme(legend.position="none", panel.grid.major.y=element_line(linetype=2, color="grey50")) + dyad_color + xlab("Suvey Number") + ylab("Relationship Strength")
  p <- p + scale_y_continuous(breaks=seq(0,10,2)) + scale_x_continuous(breaks=seq(0,5,1))
  p <- p + scale_alpha(guide="none")    
  print(p)
  # close the pdf
  dev.off()
}

dyad_trajectory <- function(edges, semester_a, night_a, scale_factor=3, point_size=1){
  # get subset of edges
  edges_subset <- edges[with(edges, semester==semester_a & night==night_a & dyad==TRUE),]
  # setup plot
  edges_subset$dyad_id <- substr(edges_subset$sender_final_id, 2, 999)
  # take only the columns we need
  edges_subset <- edges_subset[, c("dyad_id", "sender_role", "survnum", "sn2")]
  # reshape
  edges_subset = dcast(edges_subset, dyad_id + survnum ~ sender_role, value.var="sn2", fun.aggregate=sum)
  # order them so lines plot correctly
  edges_subset <- edges_subset[with(edges_subset, order(dyad_id, survnum)),]
 
  # plot each dyad separately 
  grid_size <- as.integer(sqrt(length(unique(edges_subset$dyad_id))))+1
  filen <- paste(paste(paste(output_dir, semester_a, "_dyad_trajectory", sep="") , night_a, sep="_"), ".pdf", sep="")
  pdf(filen, width=scale_factor*5, height=scale_factor*5)
  # plot
  colormap = palette(viridis(5, option="viridis"))
  p <- ggplot(edges_subset, aes(x=mentee, y=mentor, color=as.factor(survnum)))
  p <- p + geom_point() + geom_path(aes(group=edges_subset$dyad_id))
  p <- p + theme(legend.position="bottom", panel.grid.major=element_line(linetype=2, color="grey25"), panel.border=element_rect(colour="black", fill=NA, size=1)) 
  p <- p + labs(x="Mentee Strength", y="Mentor Strength", color="Survey Number")
  p <- p + scale_y_continuous(breaks=seq(0,10,5), limits=c(0,10)) + scale_x_continuous(breaks=seq(0,10,5), limits=c(0,10))
  p <- p + scale_color_manual(values=colormap)
  p <- p + facet_wrap(~edges_subset$dyad_id)
  print(p)
  dev.off()
 
  # plot average behavior instead
  averages <- aggregate(edges_subset[,c("survnum", "mentor", "mentee")], by=list(edges_subset$survnum), FUN="mean")
  filen <- paste(paste(paste(output_dir, semester_a, "_dyad_trajectory", sep="") , night_a, sep="_"), "_average.pdf", sep="")
  pdf(filen, width=scale_factor*3, height=scale_factor*3)
  # plot
  p <- ggplot(averages, aes(x=mentee, y=mentor, color=as.factor(survnum)))
  p <- p + geom_point() + geom_path(color=as.factor(averages$survnum))
  p <- p + theme(legend.position="bottom", panel.grid.major=element_line(linetype=2, color="grey25"), panel.border=element_rect(colour="black", fill=NA, size=1)) 
  p <- p + labs(x="Mentee Strength", y="Mentor Strength", color="Survey Number")
  p <- p + scale_y_continuous(breaks=seq(0,10,2), limits=c(0,10)) + scale_x_continuous(breaks=seq(0,10,2), limits=c(0,10))
  #p <- p + ylim(0, 10) + xlim(0, 10)
  p <- p + scale_color_manual(values=colormap)
  print(p)
  dev.off()
}


strength_histo <- function(edges, semester_a, night_a, scale_factor){
  edges_of_interest <- with(edges, edges[semester==semester_a & night==night_a & sn1==1, ])
  edges_of_interest$survey_nice <- paste("Survey ", edges_of_interest$survnum, sep="")
  
  filen <- paste(paste(paste(output_dir, semester_a, "_strength_histo", sep="") , night_a, sep="_"), ".pdf", sep="")
  pdf(filen, width=scale_factor*length(unique(edges_of_interest$survnum)), height=scale_factor*length(unique(edges_of_interest$sender_role)))
  p <- ggplot(edges_of_interest, aes(sn2, fill=sender_role))
  p <- p + geom_histogram(color="black")
  p <- p + scale_fill_manual(values=role_colors2)
  p <- p + facet_grid(sender_role~survey_nice)
  p <- p + labs(x="Relationship Strength", y="Frequency", fill="Sender Role")
  p <- p + theme(legend.position="bottom", panel.grid.major=element_line(linetype=2, color="grey25"), panel.border=element_rect(colour="black", fill=NA, size=1)) 
  p <- p + scale_y_continuous(breaks=seq(0,40,10), limits=c(0,50)) + scale_x_continuous(breaks=seq(0,10,2), limits=c(0,10))
  print(p)
  dev.off()
}

betweenness_centrality <- function(adj){
  # algorithm implemented from:
  # http://citeseerx.ist.psu.edu/viewdoc/download?doi=10.1.1.11.2024&rep=rep1&type=pdf
  # create neighbor lists
  nbors <- alply(split(adj, seq(NROW(adj))), 1, function(x){which(x!=0)})
  n <- dim(adj)[1]
  CB <- vector(length=n)
  for(v in 1:n){
    CB[v] <- 0
  }
  for(s in 1:n){
    S <- rstack()
    Pi <- rep(1, n)
    P <- list()
    for(t in 1:n){
      P[[t]] <- list()
    }
    sigm <- rep(0, n)
    sigm[s] <- 1
    d <- rep(-1, n)
    d[s] <- 0
    #Q <- rpqueue()
    Q <- rdeque()
    Q <- insert_back(Q, s)
    while(!rstackdeque::empty(Q)){
      v <- peek_front(Q)
      Q <- without_front(Q)
      S <- insert_top(S, v)
      for(w in nbors[[v]]){
        if(d[w] < 0){
          Q <- insert_back(Q, w)
          d[w] <- d[v] + 1
        }
        if(d[w] == d[v] + 1){
          sigm[w] <- sigm[w] + sigm[v]
          P[[w]][[Pi[w]]] <- v
          Pi[w] = Pi[w] + 1
        }
      }
    }
    delt <- rep(0 ,n)
    while(!rstackdeque::empty(S)){
      w <- peek_top(S)
      S <- without_top(S)
      for(v in P[[w]]){
        delt[v] <- delt[v] + sigm[v]/sigm[w] * (1+delt[w])
      }
      if(w != s){
        CB[w] <- CB[w] + delt[w]
      }
    }
  }
  return(CB)
}

adj <- matrix(c(0, 1, 1, 0, 1, 0, 0, 1, 1, 0, 0, 1, 0, 1, 1, 0), nrow=4)
adj <- matrix(c(0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 1, 1, 0, 1, 1, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0), nrow=5)
c <- r <- 10
adj <- round(matrix(runif(r*c), r, c))

print(betweenness_centrality(adj))



#-------------------------------------------------------------------------------
#' Wrapper around mclapply to track progress
#' 
#' Based on http://stackoverflow.com/questions/10984556
#' 
#' @param X         a vector (atomic or list) or an expressions vector. Other
#'                  objects (including classed objects) will be coerced by
#'                  ‘as.list’
#' @param FUN       the function to be applied to
#' @param ...       optional arguments to ‘FUN’
#' @param mc.preschedule see mclapply
#' @param mc.set.seed see mclapply
#' @param mc.silent see mclapply
#' @param mc.cores see mclapply
#' @param mc.cleanup see mclapply
#' @param mc.allow.recursive see mclapply
#' @param mc.progress track progress?
#' @param mc.style    style of progress bar (see txtProgressBar)
#'
#' @examples
#' x <- mclapply2(1:1000, function(i, y) Sys.sleep(0.01))
#' x <- mclapply2(1:3, function(i, y) Sys.sleep(1), mc.cores=1)
#' 
#' dat <- lapply(1:10, function(x) rnorm(100)) 
#' func <- function(x, arg1) mean(x)/arg1 
#' mclapply2(dat, func, arg1=10, mc.cores=2)
#-------------------------------------------------------------------------------
mclapply2 <- function(X, FUN, ..., 
                      mc.preschedule = TRUE, mc.set.seed = TRUE,
                      mc.silent = FALSE, mc.cores = getOption("mc.cores", 2L),
                      mc.cleanup = TRUE, mc.allow.recursive = TRUE,
                      mc.progress=TRUE, mc.style=3) 
{
  if (!is.vector(X) || is.object(X)) X <- as.list(X)
  
  if (mc.progress) {
    f <- fifo(tempfile(), open="w+b", blocking=T)
    p <- parallel:::mcfork()
    pb <- txtProgressBar(0, length(X), style=mc.style)
    setTxtProgressBar(pb, 0) 
    progress <- 0
    if (inherits(p, "masterProcess")) {
      while (progress < length(X)) {
        readBin(f, "double")
        progress <- progress + 1
        setTxtProgressBar(pb, progress) 
      }
      cat("\n")
      parallel:::mcexit()
    }
  }
  tryCatch({
    result <- mclapply(X, ..., function(...) {
      res <- FUN(...)
      if (mc.progress) writeBin(1, f)
      res
    }, 
    mc.preschedule = mc.preschedule, mc.set.seed = mc.set.seed,
    mc.silent = mc.silent, mc.cores = mc.cores,
    mc.cleanup = mc.cleanup, mc.allow.recursive = mc.allow.recursive
    )
    
  }, finally = {
    if (mc.progress) close(f)
  })
  result
}

get_factors <- function(x) {
  if(x==1){
    return(numeric(0))
  }
  x <- as.integer(x)
  div <- 1+seq_len(abs(x)-2)
  factors <- div[x %% div == 0L]
  return(factors)
}



############## Functions and Classes used in Monte Carlo Simulation ##############
setRefClass(
  "GraphModel"
)
SBM <- R6Class(
  "StochBlockModel",
  public = list(
    groups = c(5, 5),
    probs=matrix(c(1.0, 0.5, 0.5, 1.0), ncol=2),
    initialize = function(groups, probs){
      self$groups <- groups
      self$probs <- probs
    },
    realize = function(){
      n <- sum(self$groups)
      adj <- matrix(nrow=n, ncol=n)
      # simulate all edges between types
      idx1 <- 1
      for(i in 1:length(self$groups)){
        n_g1 <- self$groups[i]
        idx2 <- 1
        for(j in 1:length(self$groups)){
          n_g2 <- self$groups[j]
          adj[idx1:(idx1+n_g1-1),idx2:(idx2+n_g2-1)] <- matrix(runif(n_g1*n_g2), nrow=n_g1, ncol=n_g2) < self$probs[i, j]
          if(!i==j){
            adj[idx2:(idx2+n_g2-1),idx1:(idx1+n_g1-1)] <- matrix(runif(n_g2*n_g1), nrow=n_g2, ncol=n_g1) < self$probs[j, i]
          }
          idx2 <- idx2 + n_g2
        }
        idx1 <- idx1 + n_g1
      }
      return(adj*1)
    }
  )
)

GDI <- R6Class(
  "GeneralizedDyadIndependent",
  public = list(
    groups = c(1, 1),
    probs=matrix(c(1.0, 0.5, 0.5, 1.0), ncol=2),
    initialize = function(groups, probs){
      self$groups <- groups
      self$probs <- probs
    },
    realize = function(){
      n <- dim(self$probs)[1]
      adj <- matrix(nrow=n, ncol=n)
      # simulate all edges between types
      adj <- matrix(runif(n*n), nrow=n, ncol=n) < self$probs
      return(adj*1)
    }
  )
)

##### some functions #####
# compute different statistics about a model
network_stats <- function(adj, groups=NULL){
  n <- dim(adj)[1]
  n_stats <- new.env()
  n_stats$out_degree <- t(as.array(rowSums(adj), dim=c(1, n)))
  n_stats$in_degree <- t(as.array(colSums(adj), dim=c(1, n)))
  n_stats$out_degree_ave <- mean(n_stats$out_degree)
  n_stats$in_degree_ave <- mean(n_stats$in_degree)
  n_stats$out_degree_stddev <- sqrt(var(t(n_stats$out_degree)))
  n_stats$in_degree_stddev <- sqrt(var(t(n_stats$in_degree)))
  if(!is.null(groups)){
    n_grps <- length(groups)
    group_out_degree <- list(length=n_grps)
    group_in_degree <- list(length=n_grps)
    group_out_degree_ave <- array(dim=c(1, n_grps))
    group_in_degree_ave <- array(dim=c(1, n_grps))
    group_out_degree_stddev <- array(dim=c(1, n_grps))
    group_in_degree_stddev <- array(dim=c(1, n_grps))
    idx <- 1
    for(i in 1:length(groups)){
      n_g <- groups[i]
      if(n_g==1){
        group_out_degree[[i]] <- as.array(t(sum(adj[idx:(idx+n_g-1),])))
        group_in_degree[[i]] <- as.array(t(sum(adj[,idx:(idx+n_g-1)])))
        group_out_degree_stddev[i] <- 0
        group_in_degree_stddev[i] <- 0
      } else {
        group_out_degree[[i]] <- as.array(t(rowSums(adj[idx:(idx+n_g-1),])))
        group_in_degree[[i]] <- as.array(t(colSums(adj[,idx:(idx+n_g-1)])))
        group_out_degree_stddev[i] <- sqrt(var(t(group_out_degree[[i]])))
        group_in_degree_stddev[i] <- sqrt(var(t(group_out_degree[[i]])))
      }
      group_out_degree_ave[i] <- mean(group_out_degree[[i]])
      group_in_degree_ave[i] <- mean(group_in_degree[[i]])
      idx <- idx + n_g
    }
    n_stats$group_out_degree <- group_out_degree
    n_stats$group_in_degree <- group_in_degree
    n_stats$group_out_degree_ave <- group_out_degree_ave
    n_stats$group_in_degree_ave <- group_in_degree_ave
    n_stats$group_out_degree_stddev <- group_out_degree_stddev
    n_stats$group_in_degree_stddev <- group_in_degree_stddev
  }
  n_stats$CB <- t(as.array(betweenness_centrality(adj)))
  n_stats$CB_ave <- mean(t(n_stats$CB))
  n_stats$CB_stddev <- sqrt(var(t(n_stats$CB)))
  n_stats$cycles <- list()
  n_stats$cycles_ave <- list()
  n_stats$cycles_stddev <- list()
  A <- adj
  for(i in 1:3){
    A <- A %*% adj
    n_stats$cycles[[i]] <- t(as.array(diag(A)))
    n_stats$cycles_ave[[i]] <- sum(n_stats$cycles[[i]])
    n_stats$cycles_stddev[[i]] <- sqrt(var(t(n_stats$cycles[[i]])))
  }
  return(n_stats)
}

# run a simulation of models
mc_sim <- function(net_model, N, par=FALSE, cores=3){
  run_sim <- function(i, net_m){
    return(network_stats(net_m$realize(), net_m$groups))
  }
  if(par){
    envs <- mclapply(1:N, run_sim, net_model, mc.cores=cores)
    #envs <- mclapply2(1:N, run_sim, net_model, mc.cores=3)
  } else {
    envs <- lapply(1:N, run_sim, net_model)
  }
  # combine all results
  retenv <- combine_envs(envs)
  return(retenv)
}

# combines different environments
combine_envs <- function(envs, along=1, ignore=c()){
  var_names <- names(envs[[1]])
  retenv <- new.env()
  first <- T
  for(j in 1:length(envs)){
    for(i in 1:length(var_names)){
      nam <- var_names[i]
      if(nam %in% ignore){next}
      tmp <- get(nam, envs[[j]])
      if(is.atomic(tmp)){ # Not a list:
        if(first){
          assign(nam, tmp, retenv)
        } else {
          assign(nam, abind(get(nam, retenv), tmp, along=along), retenv)
        }
      } else { # A list:
        if(first){
          assign(nam, tmp, retenv)
        } else {
          tmp2 <- get(nam, retenv)
          for(idx in 1:length(tmp2)){
            tmp2[[idx]] <- abind(tmp2[[idx]], tmp[[idx]], along=along)
          }
          assign(nam, tmp2, retenv)
        }
      }
    }
    first <- F
  }
  return(retenv)
}

# Calculate variance of each row
rowVar <- function(x){
  rowSums((x - rowMeans(x))^2)/(dim(x)[2] - 1)
}

# Calculate average and standard deviation of each row
row_summary <- function(env){
  var_names <- names(env)
  retenv <- new.env()
  first <- T
  for(i in 1:length(var_names)){
    nam <- var_names[i]
    tmp <- get(nam, env)
    if(is.atomic(tmp)){ # It's not a list
      assign(paste(nam, "_ave", sep=""), rowMeans(tmp), retenv)
      assign(paste(nam, "_stddev", sep=""), sqrt(rowVar(tmp)), retenv)
    } else { # It's a list
      tmp_ave <- list()
      tmp_stddev <- list()
      for(idx in 1:length(tmp)){
        tmp_ave[[idx]] <- rowMeans(tmp[[idx]])
        tmp_stddev[[idx]] <- sqrt(rowVar(tmp[[idx]]))
      }
      assign(paste(nam, "_ave", sep=""), tmp_ave, retenv)
      assign(paste(nam, "_stddev", sep=""), tmp_stddev, retenv)
    }
  }
  return(retenv)
}

# Plot the results.
plot_results <- function(sim_results, true_stats, bins, group_labels=NULL, save=FALSE, fprefix=""){
  plot_hist <- function(dat, vert, xlabel, main=NULL, save=FALSE, fprefix="", fpostfix="hist"){
    if(save){pdf(sprintf("%s/%s/%s_%s.pdf", output_dir, "mc_models", fprefix, fpostfix))}
    xmin <- min(vert, dat)
    xmax <- max(vert, dat)
    xmin <- xmin-0.1*(xmax-xmin)
    xmax <- xmax+0.1*(xmax-xmin)
    hist(dat, breaks=bins, xlim=c(xmin, xmax), xlab=xlabel, main=main)
    abline(v=vert, col="red", lty=2)
    if(save){dev.off()}
  }
  panel_hist <- function(dats, verts, xlabel, mains=NULL, main=NULL, save=FALSE, fprefix="", fpostfix="panel_hist"){
    if(save){pdf(sprintf("%s/%s/%s_%s.pdf", output_dir, "mc_models", fprefix, fpostfix))}
    ng <- length(verts)
    if(is.null(mains)){
      mains <- sprintf("Group %d", 1:ng)
    }
    rows <- round(sqrt(ng))
    cols <- round(ng/rows)
    par(mfrow=c(cols, rows), oma=c(0, 0, 2, 0))
    for(i in 1:ng){
      if(is.atomic(dats)){
        plot_hist(dats[,i], verts[i], xlabel, mains[i], save=FALSE, fprefix=fprefix)
      } else {
        plot_hist(dats[[i]], verts[[i]], xlabel, mains[i], save=FALSE, fprefix=fprefix)
      }
    }
    title(main, outer=TRUE)
    par(mfrow=c(1,1), oma=c(0,0,0,0))
    if(save){dev.off()}
  }
  # plot ave in and out degrees
  plot_hist(sim_results$in_degree_ave, true_stats$in_degree_ave, "", "Average In Degree", save, fprefix, "in_deg_ave")
  plot_hist(sim_results$out_degree_ave, true_stats$out_degree_ave, "", "Average Out Degree", save, fprefix, "out_deg_ave")
  panel_hist(sim_results$group_in_degree_ave, true_stats$group_in_degree_ave, "", group_labels, "Average In Degree", save, fprefix, "group_in_deg_ave")
  panel_hist(sim_results$group_out_degree_ave, true_stats$group_out_degree_ave, "", group_labels, "Average Out Degree", save, fprefix, "group_out_deg_ave")
  # plot stddev in and out degrees
  plot_hist(sim_results$in_degree_stddev, true_stats$in_degree_stddev, "", "Standard Deviaion In Degree", save, fprefix, "in_deg_stddev")
  plot_hist(sim_results$out_degree_stddev, true_stats$out_degree_stddev, "", "Standard Deviaion Out Degree", save, fprefix, "out_deg_stddev")
  panel_hist(sim_results$group_in_degree_stddev, true_stats$group_in_degree_stddev, "", group_labels, "Standard Deviation In Degree", save, fprefix, "group_in_deg_stddev")
  panel_hist(sim_results$group_out_degree_stddev, true_stats$group_out_degree_stddev, "", group_labels, "Standard Deviaion Out Degree", save, fprefix, "group_out_deg_stddev")
  # plot betweenness centrality
  plot_hist(sim_results$CB_ave, true_stats$CB_ave, "", "Average Betweenness Centrality", save, fprefix, "ave_bet_cent")
  # plot cycles
  cycle_labels <- paste(2:(length(true_stats$cycles_ave)+1), "-cycles Average", sep="")
  panel_hist(sim_results$cycles_ave, true_stats$cycles_ave, "", cycle_labels, "Cycles", save, fprefix, "cycles_ave")
  cycle_labels <- paste(2:(length(true_stats$cycles_stddev)+1), "-cycles Standard Deviation", sep="")
  panel_hist(sim_results$cycles_stddev, true_stats$cycles_stddev, "", cycle_labels, "Cycles", save, fprefix, "cycles_stddev")
}

# Functions to simulate/summarize for each model type
SBM_modeling <- function(night, semester, N, bins, par=FALSE, cores=NULL){
  # construct probability matrix
  vertices <- present_45[present_45$semester==sem & present_45$night==night, ]
  vertices <- merge(participants, vertices, by.x=c("semester", "night", "final_id"), by.y=c("semester", "night", "final_id"))
  vertices <- vertices[vertices$role == "mentor" | vertices$role == "mentee",]
  vertices <- vertices[order(vertices$role),]
  n_verts <- nrow(vertices)
  p <- matrix(rep(0, n_verts*n_verts), nrow=n_verts)
  for(i in 1:n_verts){
    for(j in 1:n_verts){
      if(i==j){next}
      sender <- vertices[i,]
      receiver <- vertices[j,]
      pred_row <- data.frame("I_sender_mentee"=(sender$role=="mentee")*1, "I_receiver_mentee"=(receiver$role=="mentee")*1)
      prob <- drop(merge(m_sbm$X_pred, pred_row)[, "predicted_prob"])
      p[i, j] <- prob
    }
  }
  # construct adjacency matrix
  vert_map <- hashmap(vertices$final_id, 1:n_verts)
  edges_ <- X_sbm[X_sbm$semester==sem & X_sbm$night==night & X_sbm$edge==1, ]
  senders <- edges_$sender_final_id
  receivers <- edges_$receiver_final_id
  A <- matrix(rep(0, n_verts*n_verts), nrow=n_verts)
  for(i in 1:dim(edges)[1]){
    A[vert_map[[senders[i]]], vert_map[[receivers[i]]]] <- 1
  }
  
  # create model
  groups <- as.data.frame((vertices %>% count(role)))[,2]
  m_gdi_gen <- GDI$new(groups=groups, probs=p)
  # run simulation
  results <- mc_sim(m_gdi_gen, N, par=par, cores=cores)
  empirical <- network_stats(A, groups)
  plot_results(results, empirical, bins, c("Mentors", "Mentees"), save=TRUE, fprefix=sprintf("%s_%d_%s_%s", "SBM", N, sem, night))
  return(list(results, empirical))
}

SBM2_modeling <- function(night, semester, N, bins, par=FALSE, cores=NULL){
  # construct probability matrix
  vertices <- present_45[present_45$semester==sem & present_45$night==night, ]
  vertices <- merge(participants, vertices, by.x=c("semester", "night", "final_id"), by.y=c("semester", "night", "final_id"))
  vertices <- vertices[vertices$role == "mentor" | vertices$role == "mentee",]
  vertices <- vertices[order(vertices$role),]
  n_verts <- nrow(vertices)
  p <- matrix(rep(0, n_verts*n_verts), nrow=n_verts)
  for(i in 1:n_verts){
    for(j in 1:n_verts){
      if(i==j){next}
      sender <- vertices[i,]
      receiver <- vertices[j,]
      pred_row <- data.frame("I_mfam_night"=conditions[conditions$semester==sem & conditions$night==night, 3], "I_sender_mentee"=(sender$role=="mentee")*1, "I_receiver_mentee"=(receiver$role=="mentee")*1)
      prob <- drop(merge(m_sbm2$X_pred, pred_row)[, "predicted_prob"])
      p[i, j] <- prob
    }
  }
  # construct adjacency matrix
  vert_map <- hashmap(vertices$final_id, 1:n_verts)
  edges_ <- X_sbm[X_sbm$semester==sem & X_sbm$night==night & X_sbm$edge==1, ]
  senders <- edges_$sender_final_id
  receivers <- edges_$receiver_final_id
  A <- matrix(rep(0, n_verts*n_verts), nrow=n_verts)
  for(i in 1:dim(edges)[1]){
    A[vert_map[[senders[i]]], vert_map[[receivers[i]]]] <- 1
  }
  
  # create model
  groups <- as.data.frame((vertices %>% count(role)))[,2]
  m_gdi_gen <- GDI$new(groups=groups, probs=p)
  # run simulation
  results <- mc_sim(m_gdi_gen, N, par=par, cores=cores)
  empirical <- network_stats(A, groups)
  plot_results(results, empirical, bins, c("Mentors", "Mentees"), save=TRUE, fprefix=sprintf("%s_%d_%s_%s", "SBM2", N, sem, night))
  return(list(results, empirical))
}

DI_modeling <- function(night, semester, N, bins, par=FALSE, cores=NULL){
  # construct probability matrix
  vertices <- present_45[present_45$semester==sem & present_45$night==night, ]
  vertices <- merge(participants, vertices, by.x=c("semester", "night", "final_id"), by.y=c("semester", "night", "final_id"))
  vertices <- vertices[vertices$role == "mentor" | vertices$role == "mentee",]
  vertices <- vertices[order(vertices$role),]
  n_verts <- nrow(vertices)
  p <- matrix(rep(0, n_verts*n_verts), nrow=n_verts)
  for(i in 1:n_verts){
    for(j in 1:n_verts){
      if(i==j){next}
      sender <- vertices[i,]
      receiver <- vertices[j,]
      sender_dyad <- substr(sender$final_id, 2, 999)
      receiver_dyad <- substr(receiver$final_id, 2, 999)
      sender_mfam <- sender$menfamid
      receiver_mfam <- receiver$menfamid
      if(sender$role == receiver$role){
        pred_row <- data.frame("I_mfam_night"=conditions[conditions$semester==sem & conditions$night==night, 3], 
                               "I_same_mfam_diff_dyad"= (sender_dyad!=receiver_dyad & sender_mfam==receiver_mfam)*1,
                               "I_same_gender"=(sender$gender==receiver$gender)*1)
      } else {
        pred_row <- data.frame("I_mfam_night"=conditions[conditions$semester==sem & conditions$night==night, 3], 
                               "I_same_dyad"= (sender_dyad==receiver_dyad)*1,
                               "I_same_mfam_diff_dyad"= (sender_dyad!=receiver_dyad & sender_mfam==receiver_mfam)*1,
                               "I_same_gender"=(sender$gender==receiver$gender)*1)
      }
      pred_row[, is.na(pred_row)] <- FALSE
      if(sender$role=="mentor" & receiver$role=="mentor"){
        rel_model <- m_r2r
      } else if(sender$role=="mentor" & receiver$role=="mentee"){
        rel_model <- m_r2e
      } else if(sender$role=="mentee" & receiver$role=="mentor"){
        rel_model <- m_e2r
      } else if(sender$role=="mentee" & receiver$role=="mentee"){
        rel_model <- m_e2e
      }
      prob <- drop(merge(rel_model$X_pred, pred_row)[, "predicted_prob"])
      p[i, j] <- prob
    }
  }
  # construct adjacency matrix (can still use X_sbm in this case)
  vert_map <- hashmap(vertices$final_id, 1:n_verts)
  edges_ <- X_sbm[X_sbm$semester==sem & X_sbm$night==night & X_sbm$edge==1, ]
  senders <- edges_$sender_final_id
  receivers <- edges_$receiver_final_id
  A <- matrix(rep(0, n_verts*n_verts), nrow=n_verts)
  for(i in 1:dim(edges)[1]){
    A[vert_map[[senders[i]]], vert_map[[receivers[i]]]] <- 1
  }
  
  # create model
  groups <- as.data.frame((vertices %>% count(role)))[,2]
  m_gdi_gen <- GDI$new(groups=groups, probs=p)
  # run simulation
  results <- mc_sim(m_gdi_gen, N, par=par, cores=cores)
  empirical <- network_stats(A, groups)
  plot_results(results, empirical, bins, c("Mentors", "Mentees"), save=TRUE, fprefix=sprintf("%s_%d_%s_%s", "DI", N, sem, night))
  return(list(results, empirical))
}
